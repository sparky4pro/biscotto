//! # Build System
//!
//! `#load "build/build.bl"`
//!
//! Compiler-integrated build pipeline. The build pipeline can be used to manage the entire project
//! compilation process directly in BL. All you need is to create a build file called `build.bl`.
//!
//! Example of a minimal build.bl:
//! ```bl
//! main :: fn () s32 {
//!     // create a new executable target
//!     exe :: add_executable("MyProgram");
//!
//!     // add 'main.bl' file into the target 'exe'
//!     add_unit(exe, "main.bl");
//!
//!     // start compilation
//!     compile(exe);
//!     return 0;
//! }
//! ```
//!
//! Start the build pipeline using your build.bl file:
//! ```
//! $ blc -build
//! ```
//!
//! The compiler will automatically use the build.bl file as a build script and execute the `main`
//! function at compile-time. The `build/build.bl` file containing the compiler API for build pipeline
//! manipulation is loaded implicitly.
//!
//! **Warning**: The Build API is available only at compile-time.
//!
//! ## Basics
//!
//! ### Create a new executable target
//!
//! A target represents a single build target consisting of build Units, where each Unit represents
//! one source file required for compilation. It is essentially a target compiled into an executable
//! or binary file. Use the [add_executable](#add_executable) function to specify your target. Several
//! options related to the target are described later in this documentation.
//!
//! ```bl
//! exe :: add_executable("MyProgram");
//! ```
//!
//! ### Add a file to a target
//!
//! Use the [add_unit](#add_unit) function to add source files to the target. There is no need to add
//! all files you want to use; the general `load` and `import` mechanisms will handle that automatically.
//! Only `main` or entry-point files must be included explicitly.
//!
//! ```bl
//! add_unit(exe, "main.bl");
//! ```
//!
//! ### Specify the output directory
//!
//! The output directory is the directory where all compiler-produced files will be written
//! (for example, native executables). Use the [set_output_dir](#set_output_dir) function to specify
//! this directory. By default, the current directory is used.
//!
//! ```bl
//! set_output_dir(exe, "bin");
//! ```
//!
//! ### Compile the target
//! ```bl
//! compile(exe);
//! ```
//!
//! ### Command-line arguments
//! All arguments passed after the `-build` compiler flag are automatically forwarded to the
//! `command_line_arguments` global variable. This allows customization of the build command by
//! adding project-specific build flags. See the [`extra/argparse`](modules_argparse.html) module.
//!

/// Global builder options.
BuilderOptions :: struct {
	/// Toggle verbose mode. (Off by default.)
	verbose: bool;
	/// Toggle coloring the terminal output. (Off by default.)
	no_color: bool;
	/// Silent mode reduces amount of stuff printed to the standard output to minimum. (Off by default.)
	silent: bool;
	/// Toggle multithreading. (On by default.)
	no_jobs: bool;
	/// Disable all compiler warnings. (Off by default.)
	no_warning: bool;
	/// Use full (absolute) paths in compiler reports. (Off by default.)
	full_path_reports: bool;
	/// Toggle check of unused symbols. (Off by default.)
	no_usage_check: bool;
	/// Toggle printing of some compilation statistics. (Off by default.)
	stats: bool;
	/// Toggle experimantal targets. (Off by default.)
	enable_experimental_targets: bool;
	/// Release memory after compilation. When the compiler is executed as a single-shot application
	/// (start -> compile -> exit), memory cleanup can be left to the operating system to improve
	/// compilation speed. (Off by default.)
	do_cleanup_when_done: bool;
	/// Maximum count of error reported by the compiler.
	error_limit: s32;
	/// Enable legacy color output on Windows for terminals not supporting ANSI color codes.
	legacy_colors: bool;
	/// Report all warnings as errors.
	warnings_as_errors: bool;

	_doc_out_dir: *C.char; // private for now
}

/// Returns copy of current builder options. These are by default initializad from command line
/// arguments passed to the compiler.
get_builder_options :: fn () BuilderOptions {
	opt: BuilderOptions;
	__builder_get_options(&opt);
	return opt;
}

/// Overrides current builder options previously set from the command line or by calling this function.
set_builder_options :: fn (opt: BuilderOptions) {
	__builder_set_options(&opt);
}

/// Target is representation of whole program workspace, it's a consist of Units, every unit
/// represents one source file.
Target :: struct { // !!! ABI sync TargetOptions !!!
	/// See [TargetKind](#TargetKind).
	kind: TargetKind;
	/// Specify build mode of the target. See [BuildMode](#BuildMode)
	build_mode: BuildMode;
	/// Specify debug information format used for target in debug mode. See [DebugInfo](#DebugInfo).
	debug_info_kind: DebugInfo;
	/// Enable split of function arguments and return value into registers.
	register_split: bool;
	/// Verify LLVM module.
	verify_llvm: bool;
	/// Execute compile-time tests.
	run_tests: bool;
	/// Reduce compile-time tests output (remove results section).
	tests_minimal_output: bool;
	/// Disable default API import.
	no_api: bool;
	/// Copy all known dependencies into output folder.
	copy_dependencies: bool;
	/// Execute main function in compile-time.
	run: bool;
	/// Print lexer output.
	print_tokens: bool;
	/// Print AST.
	print_ast: bool;
	/// Print assembly scope structure in dot Graphviz format.
	print_scopes: bool;
	print_scopes_mode: ScopeDumpMode;
	/// Emit LLVM IR code into file.
	emit_llvm: bool;
	/// Emit asm code into file.
	emit_asm: bool;
	/// Emit MIR code into file.
	emit_mir: bool;
	/// Disable generation of a native binary.
	no_bin: bool;
	/// Disable LLVM backend.
	no_llvm: bool;
	/// Disable analyze pass of code generation.
	no_analyze: bool;
	/// Experimental x64 backend (debug only).
	x64: bool;
	/// See [AssertMode](#AssertMode).
	assert_mode: AssertMode;
	/// Check syntax only.
	syntax_only: bool;
	/// Enable virtual machine debugger.
	vmdbg_enabled: bool;
	/// Specify the MIR instruction ID to break on when the virtual machine debugger is attached.
	vmdbg_break_on: s32;
	/// Enable experimental build targets.
	enable_experimental_targets: bool;
	/// Target triple according to LLVM.
	triple: TargetTriple;
}

ScopeDumpMode :: enum {
	PARENTING = 0;
	INJECTION = 1;
}

/// Specification of compiler output binary kind.
TargetKind :: enum {
	EXECUTABLE    = 0;
	SHARED_LIBRARY = 1;
}

TargetArch :: enum s32 {
	UNKNOWN = 0;
	X86_64  = 1;
	AARCH64 = 2;
	ARM64   = 3;
}

TargetVendor :: enum s32 {
	UNKNOWN = 0;
	PC      = 1;
	APPLE   = 2;
}

TargetSystem :: enum s32 {
	UNKNOWN = 0;
	WINDOWS = 1;
	DARWIN  = 2;
	LINUX   = 3;
}

TargetEnvironment :: enum s32 {
	UNKNOWN = 0;
	MSVC    = 1;
	GNU     = 2;
	MUSL    = 3;
}

TargetTriple :: struct {
	arch: TargetArch;
	vendor: TargetVendor;
	os: TargetSystem;
	env: TargetEnvironment;
}

/// Specify the target build mode. Each [Target](#Target) can be compiled with various configuration
/// options. The `BuildMode` determines which set of compiler options is used.
BuildMode :: enum s32 {
	/// Generates debug symbols and produces a binary without optimizations. The `IS_DEBUG` global
	/// variable is set to `true` in this mode (`false` in all other modes).
	DEBUG = 0;
	/// Fast release mode. No debug symbols are produced, and all possible optimizations are applied
	/// to generate the fastest possible binary.
	/// Assertions are disabled unless `Target.assert_mode` is `ALWAYS_ENABLED`.
	RELEASE_FAST = 1;
	/// Small release mode. No debug symbols are produced, and optimizations are applied to generate
	/// a reasonably fast and as small as possible binary.
	/// Assertions are disabled unless `Target.assert_mode` is `ALWAYS_ENABLED`.
	RELEASE_SMALL = 2;
	/// Release mode with debug symbols. Optimizations are applied to generate a reasonably fast and
	/// as small as possible binary.
	/// Assertions are disabled unless `Target.assert_mode` is `ALWAYS_ENABLED`.
	RELEASE_WITH_DEBUG_INFO = 3;
}

/// Debug information format.
DebugInfo :: enum s32 {
	DWARF = 0;
	CODE_VIEW = 1;
}

/// Specification of the `assert` mode used for a `Target`.
AssertMode :: enum s32 {
	/// The compiler emits assertions in [BuildMode](#BuildMode).DEBUG and skips assertions in all
	/// optimized release modes.
	DEFAULT = 0;
	/// Force-enable assertions in all build modes.
	ALWAYS_ENABLED = 1;
	/// Force-disable assertions in all build modes.
	ALWAYS_DISABLED = 2;
}

/// Add a new executable target to the current compilation queue. The newly created target
/// can be compiled explicitly using [compile](#compile), or [compile_all](#compile_all) can be used
/// to compile all added targets at once.
///
/// ### Example
/// ```bl
/// main :: fn () s32 {
///     exe :: add_executable("MyProgram");
///     add_unit(exe, "src/main.bl");
///
///     mode :: get_build_mode(exe);
///     switch mode {
///         BuildMode.DEBUG {
///             set_output_dir(exe, "build/debug");
///         }
///
///         BuildMode.RELEASE_SMALL,
///         BuildMode.RELEASE_FAST {
///             set_output_dir(exe, "build/release");
///         }
///     }
///     compile(exe);
///     return 0;
/// }
/// ```
add_executable :: fn (name: string_view) *Target {
	if name.len == 0 { panic("Invalid executable name!"); }
	return __add_target(strtoc(name), cast(s32) TargetKind.EXECUTABLE);
}

/// Add a new shared library target to the current compilation queue.
add_library :: fn (name: string_view) *Target {
	if name.len == 0 { panic("Invalid library name!"); }
	return __add_target(strtoc(name), cast(s32) TargetKind.SHARED_LIBRARY);
}

/// Add a new source file to the `target`. The function does nothing if `filepath` is already present
/// in the `target` assembly.
add_unit :: fn (target: *Target, filepath: string_view) {
	if !target { panic("Invalid target!"); }
	if filepath.len == 0 { panic("Invalid unit path!"); }
	__add_unit(target, strtoc(filepath));
}

/// Start compilation of the `target` assembly and return `ok` or `error` if compilation fails.
compile :: fn (target: *Target) Error {
	if !target { panic("Invalid target!"); }
	state :: __compile(target);
	if state == 0 { return OK; }
	return error("Compilation failed!", state);
}

/// Compile all created targets one by one in the order in which they were created.
/// See also [compile](#compile).
compile_all :: fn () Error {
	state :: __compile_all();
	if state == 0 { return OK; }
	return error("Compilation failed!", state);
}

/// Add a path for linker library lookup.
add_lib_path :: fn (target: *Target, path: string_view) {
	if !target { panic("Invalid target!"); }
	if path.len == 0 { panic("Invalid library path!"); }

	__add_lib_path(target, strtoc(path));
}

/// Add a new immutable boolean variable to the global scope of the target assembly.
add_bool_constant :: fn (target: *Target, name: string_view, value: bool, loc := #call_location) {
	if !target then panic("Invalid target!");
	if name.len == 0 then panic("Invalid constant name!");

	__add_bool_user_define(target, auto name.ptr, auto name.len, value, auto loc._internal);
}

/// Link a dynamic library. Only the name is required (without extension or prefix). The compiler
/// will look for this library in the working directory, the system `PATH`, and the `linker_lib_path`
/// variable specified in the `bl.conf` file (use `blc --where-is-config` to get the file location).
/// You can add custom search locations using the `add_lib_path` function.
///
/// The linked library can also be used during compile-time execution. In that case, all required
/// symbols are loaded at compile time using `dlopen`.
///
/// Platform-specific library naming rules:
///
/// * On Linux, the name is extended with the `lib` prefix and the `.so` extension.
/// * On macOS, the name is extended with the `lib` prefix and the `.dylib` extension.
/// * On Windows, the name is extended only with the `.dll` extension.
///
/// ### Example
/// ```bl
/// main :: fn () s32 {
///     exe :: add_executable("MyGame");
///     add_unit(exe, "src/main.bl");
///
///     switch PLATFORM {
///         Platform.WINDOWS { target_windows(exe); }
///         default          { panic("Unknown build target!"); }
///     }
///     compile(exe);
///     return 0;
/// }
///
/// target_windows :: fn (exe: *Target) {
///     link_library(exe, "freetype");
///     link_library(exe, "zlib");
///     link_library(exe, "png");
/// }
/// ```
link_library :: fn (target: *Target, name: string_view) {
	if !target { panic("Invalid target!"); }
	if name.len == 0 { panic("Invalid library name!"); }

	__link_library(target, strtoc(name));
}

/// Link a static library. Only the name is required (without extension or prefix). The compiler
/// will look for this library in the working directory, the system `PATH`, and the `linker_lib_path`
/// variable specified in the `bl.conf` file (use `blc --where-is-config` to get the file location).
/// You can add custom search locations using the `add_lib_path` function.
///
/// The linked library **cannot** be used during compile-time execution, because the compiler cannot
/// load static libraries at runtime.
///
/// Platform-specific library naming rules:
///
/// * On Linux and macOS, the name is extended with the `lib` prefix and the `.a` extension.
/// * On Windows, the name is extended only with the `.lib` extension.
link_static_library :: fn (target: *Target, name: string_view) {
	if !target { panic("Invalid target!"); }
	if name.len == 0 { panic("Invalid library name!"); }

	using Platform;
	switch PLATFORM {
		WINDOWS {
			append_linker_options(target, tprint("%.lib", name));
		}

		LINUX, DARWIN {
			append_linker_options(target, tprint("lib%.a", name));
		}

		default { panic("Unsupported target for static linking!"); }
	}
}

/// Link a framework on macOS.
link_framework :: fn (target: *Target, name: string_view) {
	if !target { panic("Invalid target!"); }
	if name.len == 0 { panic("Invalid framework name!"); }
	append_linker_options(target, tprint("-framework %", name));
}

/// Add a framework search path on macOS.
add_framework_path :: fn (target: *Target, path: string_view) {
	if !target { panic("Invalid target!"); }
	if path.len == 0 { panic("Invalid framework path!"); }
	append_linker_options(target, tprint("-F\"%\"", path));
}

/// Append raw string directly to the linker command. The passed option is added without any
/// processing or compatibility validation.
append_linker_options :: fn (target: *Target, option: string_view) {
	if !target { panic("Invalid target!"); }
	if option.len == 0 { return; }
	__append_linker_options(target, strtoc(option));
}

/// Set the build output directory. This is the directory where all output files will be written.
/// For example, a different output directory can be set for each build mode.
///
/// The directory path `dir` may contain non-existing directories separated by `/`. The compiler
/// will create all missing directories in the specified path.
///
/// The specified directory is also used for build temporary files.
set_output_dir :: fn (target: *Target, dir: string_view) {
	if !target { panic("Invalid target!"); }
	if dir.len < 1 then return;
	__set_output_dir(target, strtoc(dir));
}

/// Get output directory specified by [set_output_dir](#set_output_dir) or empty string.
get_output_dir :: fn (target: *Target) string_view {
	if !target { panic("Invalid target!"); }
	cdir :: __get_output_dir(target);
	if !cdir { return str_view_empty; }
	return ctostr(cdir);
}

/// Set the module directory `dir` for the `target`. When the `#import` directive is used, the
/// compiler searches this directory first when resolving modules. If the module is not found,
/// the default compiler API location is used. The default location is specified as `lib_dir`
/// in the `bl.conf` file (use `blc --where-is-config` to get the file location).
set_module_dir :: fn (target: *Target, dir: string_view) {
	if !target { panic("Invalid target!"); }
	if dir.len < 1 then return;
	__set_module_dir(target, strtoc(dir));
}

/// Get the output directory specified by [set_output_dir](#set_output_dir), or an empty string
/// if no directory was set.
get_module_dir :: fn (target: *Target) string_view {
	if !target { panic("Invalid target!"); }
	cdir :: __get_module_dir(target);
	if !cdir { return str_view_empty; }
	return ctostr(cdir);
}

/// Get the module directory specified by [set_module_dir](#set_module_dir) or empty string.
get_default_module_dir :: fn () string_view {
	cdir :: __get_default_module_dir();
	if !cdir then return str_view_empty;
	return ctostr(cdir);
}

/// Return the target triple of the current host machine.
get_default_triple :: fn () TargetTriple {
	result: TargetTriple;
	__get_default_triple(&result);
	return result;
}

/// Convert a target triple to a string.
///
/// !!! note
///     The returned string is allocated using the current temporary allocator.
triple_to_string :: fn (triple: TargetTriple) string_view {
	buf: [128]C.char #noinit;
	len :: __triple_to_string(&triple, buf.ptr, auto buf.len);
	return tprint("%", ctostr(buf.ptr, len));
}

#scope_private
#import "std/string"
#import "std/print"

C :: #import "libc";

__add_target :: fn (name: *C.char, kind: C.int) *Target #extern;
__add_unit :: fn (target: *Target, filepath: *C.char) #extern;
__add_bool_user_define :: fn (target: *Target, sym_name: *C.char, sym_name_len: s32, value: bool, ast_node: *u8) #extern;
__compile :: fn (target: *Target) C.int #extern;
__compile_all :: fn () C.int #extern;
__add_lib_path :: fn (target: *Target, path: *C.char) #extern;
__link_library :: fn (target: *Target, name: *C.char) #extern;
__append_linker_options :: fn (target: *Target, option: *C.char) #extern;
__set_output_dir :: fn (target: *Target, dir: *C.char) #extern;
__get_output_dir :: fn (target: *Target) *C.char #extern;
__set_module_dir :: fn (target: *Target, dir: *C.char) #extern;
__get_module_dir :: fn (target: *Target) *C.char #extern;
__get_default_module_dir :: fn () *C.char #extern;
__get_default_triple :: fn (triple: *TargetTriple) #extern;
__triple_to_string :: fn (triple: *TargetTriple, buf: *C.char, buf_len: C.int) C.int #extern;
__builder_get_options :: fn (opt: *BuilderOptions) #extern;
__builder_set_options :: fn (opt: *BuilderOptions) #extern;

