/// Returns unique type identificator in compile-time.
typeid :: fn (v: type #comptime) u64 #comptime {
	return cast(u64) typeinfo(v);
}

/// Returns `true` if the `T` type is an integer type.
is_number :: fn (T: type #comptime) bool #comptime {
	return typeinfo(T).kind == TypeKind.INT;
}

/// Returns `true` if the `T` type is an floating point number type.
is_real :: fn (T: type #comptime) bool #comptime {
	return typeinfo(T).kind == TypeKind.REAL;
}

/// Returns `true` if the `T` type is an integer or floating point number type (f32 or f64).
is_real_or_number :: fn (T: type #comptime) bool #comptime {
	return typeinfo(T).kind == TypeKind.INT || typeinfo(T).kind == TypeKind.REAL;
}

/// Returns true if the `T` type is a signed integer type.
is_signed_number :: fn (T: type #comptime) bool #comptime {
	info :: cast(*TypeInfoInt)typeinfo(T);
	return info.kind == TypeKind.INT && info.is_signed;
}

/// Returns true if the `T` type is a pointer type.
is_pointer :: fn (T: type #comptime) bool #comptime {
	return typeinfo(T).kind == TypeKind.PTR;
}

/// Returns true if the `T` type is a function type.
is_function :: fn (T: type #comptime) bool #comptime {
	return typeinfo(T).kind == TypeKind.FN;
}

/// Returns true if the `T` type is a struct type.
is_struct :: fn (T: type #comptime) bool #comptime {
	return typeinfo(T).kind == TypeKind.STRUCT;
}

/// Returns true if the `T` type is a union type.
is_union :: fn (T: type #comptime) bool #comptime {
	info :: cast(*TypeInfoStruct) typeinfo(T);
	if info.kind != TypeKind.STRUCT then return false;
	return info.is_union;
}

/// Returns `true` if the `T` type is an enumerator type.
is_enum :: fn (T: type #comptime) bool #comptime {
	return typeinfo(T).kind == TypeKind.ENUM;
}

//
// Enum utility functions.
//

/// Resolve number of enum type variants.
enum_variant_count :: fn (TEnum: type #comptime) s64 #comptime {
	info :: typeinfo(TEnum);
	static_assert(info.kind == TypeKind.ENUM);
	return (cast(*TypeInfoEnum)info).variants.len;
}

/// Resolve enum variant name.
enum_variant_name :: fn (T: type #comptime, index: s64) string_view #inline {
	info :: cast(*TypeInfoEnum) typeinfo(T);
	static_assert(info.kind == TypeKind.ENUM);
	assert(index < info.variants.len);
	return info.variants[index].name;
}

/// Resolve enum variant value.
enum_variant_value :: fn (T: type #comptime, index: s64) T #inline {
	info :: cast(*TypeInfoEnum) typeinfo(T);
	static_assert(info.kind == TypeKind.ENUM);
	assert(index >= 0 && index < info.variants.len);
	return auto info.variants[index].value;
}

//
// Struct utility functions.
//

/// Resolve number of struct type members.
struct_member_count :: fn (TStruct: type #comptime) s64 #comptime {
	info :: cast(*TypeInfoStruct) typeinfo(TStruct);
	static_assert(info.kind == TypeKind.STRUCT);
	return info.members.len;
}

/// Returns type of struct member at `index`. The `index` value must be in range
/// from 0 to struct_member_count(T)-1.
get_struct_member_type :: fn (TStruct: type #comptime, index: s64 #comptime) type #comptime {
	static_assert(is_struct(TStruct));
	static_assert(index >= 0 && index < struct_member_count(TStruct));
	return __get_struct_member_type(TStruct, index);
}

/// Generates enum type from the struct `type`.
///
/// Creates enum with variants named after struct members respecting order in which members
/// were declared in the struct `type`.
struct_members_to_enum :: fn (TStruct: type #comptime) type #comptime {
	static_assert(is_struct(TStruct));
	names :: get_struct_c_names(TStruct);
	return __create_enum_type(names.ptr, names.len);
}

has_member :: fn (TStruct: type #comptime, member_name: string_view) bool {
	info :: cast(*TypeInfoStruct) typeinfo(TStruct);
	static_assert(info.kind == TypeKind.STRUCT);
	loop i := 0; i < info.members.len; i += 1 {
		if str_match(info.members[i].name, member_name) {
			return true;
		}
	}
	return false;
}

member_offset_bytes :: fn {
	member_offset_bytes_impl;
	member_offset_bytes_with_typeinfo_impl;
}

member_ptr :: fn {
	member_ptr_impl;
	member_ptr_with_type_info_impl;
}

/// Returns signed or unsigned builtin number type of the requested size.
/// The `size_bytes` must be 1, 2, 4 or 8 Bytes.
number_type :: fn (size_bytes: usize, is_signed: bool) type #comptime {
	switch size_bytes {
		1 { if is_signed { return s8;  } return u8;  }
		2 { if is_signed { return s16; } return u16; }
		4 { if is_signed { return s32; } return u32; }
		8 { if is_signed { return s64; } return u64; }
		default;
	}
	panic("Unsupported number type!");
	return s32;
}

#scope_private
C :: #import "libc";
#import "std/string"
#import "std/print"

__get_struct_member_type :: fn (t: type #comptime, index: s64) type #comptime #extern #maybe_unused;
__create_enum_type :: fn (names_ptr: **C.char, names_len: s64) type #comptime #extern #maybe_unused;

get_struct_c_names :: fn (TStruct: type #comptime) [struct_member_count(TStruct)]*C.char #comptime #maybe_unused {
	info :: cast(*TypeInfoStruct) typeinfo(TStruct);
	assert(info.kind == TypeKind.STRUCT);
	names: [struct_member_count(TStruct)]*C.char;
	loop i := 0; i < names.len; i += 1 {
		names[i] = strtoc(info.members[i].name);
	}
	return names;
}

member_offset_bytes_impl :: fn (TStruct: type #comptime, path: string_view, is_optional := false) s64 {
	static_assert(typeinfo(TStruct).kind == TypeKind.STRUCT);
	assert(path.len > 0);
	return member_offset_bytes_with_typeinfo_impl(auto typeinfo(TStruct), path, is_optional);
};

member_offset_bytes_with_typeinfo_impl :: fn (type_info: *TypeInfoStruct, path: string_view, is_optional := false) s64 {
	assert(path.len > 0);

	offset: s64;
	info := type_info;
	assert(info.kind == TypeKind.STRUCT);

	lhs: string_view;
	rhs := path;
	traverse := true;
	loop traverse {
		if !str_split_by_first(rhs, '/', &lhs, &rhs) {
			lhs = rhs;
			traverse = false;
		}
		found := false;
		loop i := 0; i < info.members.len; i += 1 {
			member :: &info.members[i];
			if str_match(member.name, lhs) {
				offset += member.offset_bytes;
				info    = auto member.base_type;
				found   = true;
				break;
			}
		}
		if !found {
			if is_optional then return -1;
			panic("No such member '%' in the structure '%' on path '%'.", lhs, info.name, path);
		}
		if traverse && info.kind != TypeKind.STRUCT {
			panic("Member '%' in the structure '%' is supposed to be struct type.", lhs, type_info.name);
		}
	}
	return offset;
}

member_ptr_impl :: fn (TMember: type #comptime, base_ptr: *?T, member_name: string_view, is_optional := false) *TMember #inline {
	offset :: member_offset_bytes(T, member_name, is_optional);
	if offset == -1 then return null;
	return auto ptr_shift_bytes(base_ptr, offset);
}

member_ptr_with_type_info_impl :: fn (base_ptr: *u8, member: *TypeInfoStructMember) *u8 #inline {
	return ptr_shift_bytes(base_ptr, member.offset_bytes);
}

