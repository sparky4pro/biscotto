//! # Static Array
//!
//! Simple API over static array buffer allocated on stack.
//!
//! ### Example
//!
//! ```bl
//! @@@examples/static_array.bl
//! ```

/// Create **Static Array** type.
///
/// ```bl
/// StaticArray :: struct {
///     data[elem_count]TElem;
///     len: s64;
/// }
/// ```
StaticArray :: fn (TElem: type #comptime, elem_count: s64 #comptime) type #comptime {
	return struct {
		data: [elem_count]TElem;
		len: s64;
	};
}

/// Push element at the end of the array and returns its address.
///
/// !!! warning
///     Asserts in case there is not enough space left in the storage.
sarray_push :: fn { impl_push_empty; impl_push; }

/// Push bunch of elements at the end of the array.
sarray_push_all :: fn (arr: *?TArr, values: []sarray_typeof_elem(TArr)) {
	assert(arr, "Passed array is invalid.");
	if values.len < 1 then return;
	if arr.len + values.len > arr.data.len {
		panic("Static array overflow, current number of elements is %, trying to push % elements, when total capacity is %.", arr.len, values.len, arr.data.len);
	}

	elem_size :: sizeof(sarray_typeof_elem(TArr));
	dest_ptr :: &arr.data[arr.len];
	arr.len += values.len;
	memcpy(auto dest_ptr, auto values.ptr, elem_size * auto values.len);
}


/// Pops the last element of the array into `out` destination and returns `true`
/// otherwise returns `false` and value of `out` stays unchanged.
sarray_pop :: fn (arr: *?TArr, out: *sarray_typeof_elem(TArr) = null) bool #inline {
	if arr.len == 0 { return false; }
	if out {
		memcpy(auto out, auto &arr.data[arr.len - 1], sizeof(@out));
	}
	arr.len -= 1;
	return true;
}

/// Duplicate first array element into `out` location (if not null) and shift all other elements by
/// one slot left (the ordeing is kept). Returns `true` in case the element was erased.
sarray_pop_first :: fn (arr: *?TArr, out: *sarray_typeof_elem(TArr) = null) bool #inline {
	if arr.len == 0 { return false; }
	if out {
		memcpy(auto out, auto &arr.data[0], sizeof(@out));
	}
	// Eventually assert?
	if arr.len == 0 { return false; }
	if out {
		memcpy(auto out, auto &arr.data[0], sizeof(@out));
	}
	sarray_erase_keep_order(arr, 0);
	return true;
}

/// Erase element on index `i` and move all following elements left using memmove. This might be slow in
/// case the array is large. Function invoke panic in case of index being out of array valid range <0, arr.len).
sarray_erase_keep_order :: fn (arr: *?TArr, i: s64) {
	assert(arr, "Passed array is invalid.");
	if i >= arr.len || i < 0 {
		panic("Array index out of range, index is % but array size is %.", i, arr.len);
	}

	if i == arr.len - 1 {
		arr.len -= 1;
		return;
	}
	elem_size :: sizeof(sarray_typeof_elem(TArr));
	size_to_move :: (arr.len - i - 1) * auto elem_size;
	memmove(auto &arr.data[i], auto &arr.data[i+1], auto size_to_move);
	arr.len -= 1;
}

/// Errase element at the index `i`. The index value must be valid in range `0 <= i < len`.
sarray_erase :: fn (arr: *?TArr, i: s64) {
	if i >= arr.len { panic("Index overflow!"); }
	if i == arr.len - 1 {
		arr.len -= 1;
		return;
	}
	TElem :: sarray_typeof_elem(TArr);
	memcpy(auto &arr.data[i], auto &arr.data[arr.len - 1], sizeof(TElem));
	arr.len -= 1;
}

/// Clear the array.
sarray_clear :: fn (arr: *?TArr) #inline {
	arr.len = 0;
}

/// Get the content of static array as an slice.
sarray_get_slice :: fn (arr: *?TArr) []sarray_typeof_elem(TArr) #inline {
	TElem :: sarray_typeof_elem(TArr);
	return []TElem.{ arr.len, arr.data.ptr };
}

/// Return type of the element.
sarray_typeof_elem :: fn (TArr: type #comptime) type #comptime {
	return @TArr.data.ptr;
}

#scope_private
impl_push :: fn (arr: *?TArr, value: sarray_typeof_elem(TArr)) *sarray_typeof_elem(TArr) #inline {
	elem :: impl_push_empty(arr);
	memcpy(auto elem, auto &value, sizeof(value));
	return elem;
}

impl_push_empty :: fn (arr: *?TArr) *sarray_typeof_elem(TArr) #inline {
	assert(arr.len + 1 <= arr.data.len);
	elem :: &arr.data[arr.len];
	arr.len += 1;
	return elem;
}
